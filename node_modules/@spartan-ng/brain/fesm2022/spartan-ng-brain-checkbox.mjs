import * as i0 from '@angular/core';
import { forwardRef, inject, DestroyRef, Renderer2, ElementRef, ChangeDetectorRef, PLATFORM_ID, signal, model, computed, input, linkedSignal, booleanAttribute, viewChild, output, effect, ChangeDetectionStrategy, Component, NgModule } from '@angular/core';
import { FocusMonitor } from '@angular/cdk/a11y';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { NG_VALUE_ACCESSOR } from '@angular/forms';

const BRN_CHECKBOX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => BrnCheckboxComponent),
    multi: true,
};
let uniqueIdCounter = 0;
const CONTAINER_POST_FIX = '-checkbox';
class BrnCheckboxComponent {
    _destroyRef = inject(DestroyRef);
    _renderer = inject(Renderer2);
    _elementRef = inject(ElementRef);
    _focusMonitor = inject(FocusMonitor);
    _cdr = inject(ChangeDetectorRef);
    _document = inject(DOCUMENT);
    _isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
    focusVisible = signal(false);
    focused = signal(false);
    /**
     * Current checked state of checkbox.
     * Can be boolean (true/false) or 'indeterminate'.
     * Can be bound with [(checked)] for two-way binding.
     */
    checked = model(false);
    /**
     * Read-only signal of current checkbox state.
     * Use this when you only need to read state without changing it.
     */
    isChecked = this.checked.asReadonly();
    /**
     * Computed data-state attribute value based on checked state.
     * Returns 'checked', 'unchecked', or 'indeterminate'.
     */
    _dataState = computed(() => {
        const checked = this.checked();
        if (checked === 'indeterminate')
            return 'indeterminate';
        return checked ? 'checked' : 'unchecked';
    });
    /**
     * Computed aria-checked attribute value for accessibility.
     * Returns 'true', 'false', or 'mixed' (for indeterminate).
     */
    _ariaChecked = computed(() => {
        const checked = this.checked();
        if (checked === 'indeterminate')
            return 'mixed';
        return checked ? 'true' : 'false';
    });
    /**
     * Unique identifier for checkbox component.
     * When provided, inner button gets ID without '-checkbox' suffix.
     * Auto-generates ID if not provided.
     */
    id = input(uniqueIdCounter++ + '');
    /**
     * Form control name for checkbox.
     * When provided, inner button gets name without '-checkbox' suffix.
     */
    name = input(null);
    /**
     * CSS classes applied to inner button element.
     */
    class = input(null);
    /**
     * Accessibility label for screen readers.
     * Use when no visible label exists.
     */
    ariaLabel = input(null, { alias: 'aria-label' });
    /**
     * ID of element that labels this checkbox for accessibility.
     * Auto-set when checkbox is inside label element.
     */
    ariaLabelledby = input(null, { alias: 'aria-labelledby' });
    mutableAriaLabelledby = linkedSignal(() => this.ariaLabelledby());
    /**
     * ID of element that describes this checkbox for accessibility.
     */
    ariaDescribedby = input(null, { alias: 'aria-describedby' });
    /**
     * Whether checkbox is required in a form.
     */
    required = input(false, { transform: booleanAttribute });
    /**
     * Whether checkbox is disabled.
     * Disabled checkboxes cannot be toggled and indicate disabled state through data-disabled attribute.
     */
    disabled = input(false, { transform: booleanAttribute });
    /**
     * Computed state for checkbox container and accessibility.
     * Manages ID, name, and disabled state.
     */
    state = computed(() => {
        const name = this.name();
        const id = this.id();
        return {
            disabled: signal(this.disabled()),
            name: name ? name + CONTAINER_POST_FIX : null,
            id: id ? id + CONTAINER_POST_FIX : null,
        };
    });
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    _onChange = () => { };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    _onTouched = () => { };
    /**
     * Reference to the checkbox button element in the template.
     */
    checkbox = viewChild.required('checkBox');
    /**
     * Event emitted when checkbox value changes.
     * Emits new checked state (true/false/'indeterminate').
     */
    changed = output();
    /**
     * Event emitted when checkbox is blurred (loses focus).
     * Used for form validation.
     */
    touched = output();
    constructor() {
        effect(() => {
            const state = this.state();
            const isDisabled = state.disabled();
            if (!this._elementRef.nativeElement || !this._isBrowser)
                return;
            const newLabelId = state.id + '-label';
            const checkboxButtonId = this.getCheckboxButtonId(state.id);
            const labelElement = this._elementRef.nativeElement.closest('label') ??
                this._document.querySelector(`label[for="${checkboxButtonId}"]`);
            if (!labelElement)
                return;
            const existingLabelId = labelElement.id;
            this._renderer.setAttribute(labelElement, 'data-disabled', isDisabled ? 'true' : 'false');
            this.mutableAriaLabelledby.set(existingLabelId || newLabelId);
            if (!existingLabelId || existingLabelId.length === 0) {
                this._renderer.setAttribute(labelElement, 'id', newLabelId);
            }
        });
    }
    /**
     * Toggles checkbox between checked/unchecked states.
     * If checkbox is indeterminate, sets to checked.
     * Does nothing if checkbox is disabled.
     */
    toggle() {
        if (this.state().disabled())
            return;
        this._onTouched();
        this.touched.emit();
        const previousChecked = this.checked();
        this.checked.set(previousChecked === 'indeterminate' ? true : !previousChecked);
        this._onChange(this.checked());
        this.changed.emit(this.checked());
    }
    ngAfterContentInit() {
        this._focusMonitor
            .monitor(this._elementRef, true)
            .pipe(takeUntilDestroyed(this._destroyRef))
            .subscribe((focusOrigin) => {
            if (focusOrigin)
                this.focused.set(true);
            if (focusOrigin === 'keyboard' || focusOrigin === 'program') {
                this.focusVisible.set(true);
                this._cdr.markForCheck();
            }
            if (!focusOrigin) {
                // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                // Angular does not expect events to be raised during change detection, so any state
                // change (such as a form control's ng-touched) will cause a changed-after-checked error.
                // See https://github.com/angular/angular/issues/17793. To work around this, we defer
                // telling the form control it has been touched until the next tick.
                Promise.resolve().then(() => {
                    this.focusVisible.set(false);
                    this.focused.set(false);
                    this._onTouched();
                    this.touched.emit();
                    this._cdr.markForCheck();
                });
            }
        });
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    /**
     * Gets proper ID for inner button element.
     * Removes '-checkbox' suffix if present in container ID.
     *
     * @param idPassedToContainer - ID applied to container element
     * @returns ID to use for inner button or null
     */
    getCheckboxButtonId(idPassedToContainer) {
        return idPassedToContainer ? idPassedToContainer.replace(CONTAINER_POST_FIX, '') : null;
    }
    /**
     * Updates internal state when control value changes from outside.
     * Handles boolean and 'indeterminate' values.
     * Part of ControlValueAccessor interface.
     *
     * @param value - New checkbox state (true/false/'indeterminate')
     */
    writeValue(value) {
        if (value === 'indeterminate') {
            this.checked.set('indeterminate');
        }
        else {
            this.checked.set(value);
        }
    }
    /**
     * Registers callback for value changes.
     * Part of ControlValueAccessor interface.
     *
     * @param fn - Function to call when value changes
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * Registers callback for touched events.
     * Part of ControlValueAccessor interface.
     *
     * @param fn - Function to call when control is touched
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * Updates disabled state from form control.
     * Part of ControlValueAccessor interface.
     *
     * @param isDisabled - Whether checkbox should be disabled
     */
    setDisabledState(isDisabled) {
        this.state().disabled.set(isDisabled);
        this._cdr.markForCheck();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCheckboxComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.8", type: BrnCheckboxComponent, isStandalone: true, selector: "brn-checkbox", inputs: { checked: { classPropertyName: "checked", publicName: "checked", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, name: { classPropertyName: "name", publicName: "name", isSignal: true, isRequired: false, transformFunction: null }, class: { classPropertyName: "class", publicName: "class", isSignal: true, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "aria-label", isSignal: true, isRequired: false, transformFunction: null }, ariaLabelledby: { classPropertyName: "ariaLabelledby", publicName: "aria-labelledby", isSignal: true, isRequired: false, transformFunction: null }, ariaDescribedby: { classPropertyName: "ariaDescribedby", publicName: "aria-describedby", isSignal: true, isRequired: false, transformFunction: null }, required: { classPropertyName: "required", publicName: "required", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { checked: "checkedChange", changed: "changed", touched: "touched" }, host: { properties: { "style": "{display: \"contents\"}", "attr.id": "state().id", "attr.name": "state().name", "attr.aria-labelledby": "null", "attr.aria-label": "null", "attr.aria-describedby": "null", "attr.data-state": "_dataState()", "attr.data-focus-visible": "focusVisible()", "attr.data-focus": "focused()", "attr.data-disabled": "state().disabled()" } }, providers: [BRN_CHECKBOX_VALUE_ACCESSOR], viewQueries: [{ propertyName: "checkbox", first: true, predicate: ["checkBox"], descendants: true, isSignal: true }], ngImport: i0, template: `
		<button
			#checkBox
			role="checkbox"
			type="button"
			[id]="getCheckboxButtonId(state().id) ?? ''"
			[name]="getCheckboxButtonId(state().name) ?? ''"
			[class]="class()"
			[attr.aria-checked]="_ariaChecked()"
			[attr.aria-label]="ariaLabel() || null"
			[attr.aria-labelledby]="mutableAriaLabelledby() || null"
			[attr.aria-describedby]="ariaDescribedby() || null"
			[attr.data-state]="_dataState()"
			[attr.data-focus-visible]="focusVisible()"
			[attr.data-focus]="focused()"
			[attr.data-disabled]="state().disabled()"
			[disabled]="state().disabled()"
			[tabIndex]="state().disabled() ? -1 : 0"
			(click)="$event.preventDefault(); toggle()"
		>
			<ng-content />
		</button>
	`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCheckboxComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-checkbox',
                    template: `
		<button
			#checkBox
			role="checkbox"
			type="button"
			[id]="getCheckboxButtonId(state().id) ?? ''"
			[name]="getCheckboxButtonId(state().name) ?? ''"
			[class]="class()"
			[attr.aria-checked]="_ariaChecked()"
			[attr.aria-label]="ariaLabel() || null"
			[attr.aria-labelledby]="mutableAriaLabelledby() || null"
			[attr.aria-describedby]="ariaDescribedby() || null"
			[attr.data-state]="_dataState()"
			[attr.data-focus-visible]="focusVisible()"
			[attr.data-focus]="focused()"
			[attr.data-disabled]="state().disabled()"
			[disabled]="state().disabled()"
			[tabIndex]="state().disabled() ? -1 : 0"
			(click)="$event.preventDefault(); toggle()"
		>
			<ng-content />
		</button>
	`,
                    host: {
                        '[style]': '{display: "contents"}',
                        '[attr.id]': 'state().id',
                        '[attr.name]': 'state().name',
                        '[attr.aria-labelledby]': 'null',
                        '[attr.aria-label]': 'null',
                        '[attr.aria-describedby]': 'null',
                        '[attr.data-state]': '_dataState()',
                        '[attr.data-focus-visible]': 'focusVisible()',
                        '[attr.data-focus]': 'focused()',
                        '[attr.data-disabled]': 'state().disabled()',
                    },
                    providers: [BRN_CHECKBOX_VALUE_ACCESSOR],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: () => [] });

const BrnCheckboxImports = [BrnCheckboxComponent];
class BrnCheckboxModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCheckboxModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnCheckboxModule, imports: [BrnCheckboxComponent], exports: [BrnCheckboxComponent] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCheckboxModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCheckboxModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnCheckboxImports],
                    exports: [...BrnCheckboxImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BRN_CHECKBOX_VALUE_ACCESSOR, BrnCheckboxComponent, BrnCheckboxImports, BrnCheckboxModule };
//# sourceMappingURL=spartan-ng-brain-checkbox.mjs.map
